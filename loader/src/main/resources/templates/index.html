<!DOCTYPE html>
<html lang="ee">
<head title="loader">
    <style>
        datalist {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            writing-mode: vertical-lr;
            width: 100%;
        }

        option {
            padding: 0;
            margin: 0;
        }

        input[type="range"] {
            overflow: hidden;
            width: 100%;
        }

        .container {
            display: flex;
            justify-content: center;
            width: 100%;
        }

    </style>

    <!-- import -->
    <!--    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>-->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3"></script>
    <!-- import -->

</head>
<body>

<div class="container">
    <label for="rpsSlide">Load, RPS:&nbsp;</label><span style="font-weight: bold" id="sliderAmount">0</span><br/>
</div>
<input id="rpsSlide" name="rpsSlide" type="range" min="0" max="1000" step="5" value="0" list="tickmarks"/>

<datalist id="tickmarks">
    <option value="0" label="disable"></option>
    <option value="100" label="100"></option>
    <option value="200" label="200"></option>
    <option value="300" label="300"></option>
    <option value="400" label="400"></option>
    <option value="500" label="500"></option>
    <option value="600" label="600"></option>
    <option value="700" label="700"></option>
    <option value="800" label="800"></option>
    <option value="900" label="900"></option>
    <option value="1000" label="1000"></option>
</datalist>

<!-- chart -->
<div id="chartContainer"></div>

<script type="text/javascript" charset="UTF-8">
    const hostsToLoad = {};
    hostsToLoad["web"] = "http://localhost:8081/string/stream";
    hostsToLoad["webflux"] = "http://localhost:8082/string/stream";

    const colors = [];
    for (let i = 0; i < 10; i++) {
        colors[i] = getRandomColor();
    }

    const nameToWsMap = {};
    const nameToLineChartMap = {};

    window.onload = (event) => {
        const rpsSlide = document.getElementById('rpsSlide');
        const rpsSliderDiv = document.getElementById("sliderAmount");

        rpsSlide.onchange = function () {
            rpsSliderDiv.innerHTML = this.value;
            loadServices(this.value);
        }


        for (const name in hostsToLoad) {
            const host = hostsToLoad[name];
            fetch("http://localhost:8088/prey", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: `{
                "name": "${name}",
                "path": "${host}"
            }`
            }).then(date => {
                connectToWs(name);
                createNamedLineChart(name);
            })
        }
    };


    function connectToWs(name) {
        const loadServiceWs = new WebSocket("ws://localhost:8088/websocket/load?" + name, []);
        nameToWsMap[name] = loadServiceWs;
        loadServiceWs.onmessage = (event) => {
            updateNamedLineChart(name, JSON.parse(event.data));
        }
    }

    function createNamedLineChart(name) {
        addCanvas(name);
        const chartContainer = {};
        const xValues = [];
        const responseTime = [];
        const successCount = [];
        const timeoutCount = [];
        const errorCount = [];
        chartContainer["xValues"] = xValues;
        chartContainer["responseTime"] = responseTime;
        chartContainer["successCount"] = successCount;
        chartContainer["timeoutCount"] = timeoutCount;
        chartContainer["errorCount"] = errorCount;
        chartContainer["lineChart"] = new Chart(name + "_lineChart", {
            type: "line",
            data: {
                labels: xValues,
                datasets: [
                    {
                        label: name + ' | Response time, ms',
                        fill: false,
                        borderColor: colors[0],
                        backgroundColor: colors[1],
                        pointStyle: 'circle',
                        pointRadius: 8,
                        pointHoverRadius: 15,
                        data: responseTime,
                        yAxisID: "axisResponseTime"
                    },
                    {
                        label: name + ' | success count',
                        fill: false,
                        borderColor: colors[2],
                        backgroundColor: colors[3],
                        pointStyle: 'circle',
                        pointRadius: 8,
                        pointHoverRadius: 15,
                        data: successCount,
                        yAxisID: "axisSuccessCount"
                    },
                    {
                        label: name + ' | timeout count',
                        fill: false,
                        borderColor: colors[4],
                        backgroundColor: colors[5],
                        pointStyle: 'circle',
                        pointRadius: 8,
                        pointHoverRadius: 15,
                        data: timeoutCount,
                        yAxisID: "axisTimeoutCount"
                    },
                    {
                        label: name + ' | error count',
                        fill: false,
                        borderColor: colors[6],
                        backgroundColor: colors[7],
                        pointStyle: 'circle',
                        pointRadius: 8,
                        pointHoverRadius: 15,
                        data: errorCount,
                        yAxisID: "axisErrorsCount"
                    }
                ]
            },
            options: {
                legend: {display: false},
                title: {
                    display: true,
                    text: "p = np",
                    fontSize: 16
                },
                scales: {
                    axisResponseTime: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        text: 'response time'
                        // grid: {
                        //     drawOnChartArea: false, // only want the grid lines for one axis to show up
                        // },
                    },
                    axisTimeoutCount: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        text: 'errors count',
                        grid: {
                            drawOnChartArea: false, // only want the grid lines for one axis to show up
                        },
                    },
                    axisErrorsCount: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        text: 'errors count',
                        grid: {
                            drawOnChartArea: false, // only want the grid lines for one axis to show up
                        },
                    },
                    axisSuccessCount: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        text: 'success count',
                        grid: {
                            drawOnChartArea: false, // only want the grid lines for one axis to show up
                        },
                    },
                }
            }
        });

        nameToLineChartMap[name] = chartContainer;
    }

    function updateNamedLineChart(name, report) {
        const chartContainer = nameToLineChartMap[name];
        safePush(chartContainer["responseTime"], report["endMs"] - report["startMs"]);
        const summary = report["summary"];
        safePush(chartContainer["xValues"], summary + ' - ' + report["totalCount"]);

        if (summary === "SUCCESS") {
            const numbers = chartContainer["successCount"];
            const nextVal = getNextValue(numbers);
            safePush(numbers, nextVal);
        } else if (summary === "TIMEOUT") {
            const numbers = chartContainer["timeoutCount"];
            const nextVal = getNextValue(numbers);
            safePush(numbers, nextVal);
        } else if (summary === "ERROR") {
            const numbers = chartContainer["errorCount"];
            const nextVal = getNextValue(numbers);
            safePush(numbers, nextVal);
        }

        chartContainer["lineChart"].update();
    }

    function getNextValue(arr) {
        const size = arr.length;

        if (size === 0) {
            return 1;
        }

        return arr[arr.length - 1] + 1;
    }

    function loadServices(rps) {
        const msg = {
            rps: rps
        }

        for (const name in hostsToLoad) {
            nameToWsMap[name].send(JSON.stringify(msg));
        }
    }

    function safePush(arr, element, maxSize = 100) {
        if (arr.length > maxSize) {
            arr.shift();
        }

        arr.push(element);
    }

    function addCanvas(name) {
        const newCanvas = document.createElement("canvas");
        newCanvas.setAttribute("id", name + "_lineChart");
        newCanvas.setAttribute("width", "100%");
        newCanvas.setAttribute("height", "22");
        const container = document.getElementById("chartContainer");
        container.appendChild(newCanvas);
    }

    function getRandomColor() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
</script>

</body>
</html>
