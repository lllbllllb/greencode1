<!DOCTYPE html>
<html lang="ee">
<head title="loader">
    <style>
        datalist {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            writing-mode: vertical-lr;
        }

        option {
            padding: 0;
            margin: 0;
        }

        .slider-container {
            display: flex;
            justify-content: space-between;
            flex-direction: column;
            align-items: center;
            position: sticky;
            top: 8px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            padding: 2px;
        }


    </style>

    <!-- import -->
    <!--    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>-->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3"></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"></script>
    <!-- import -->


    <script type="text/javascript" charset="UTF-8">
        // preysToLoad["web"] = "http://localhost:8081/string/stream";
        // preysToLoad["webflux"] = "http://localhost:8082/string/stream";
        let preysToLoad = {};
        let nameToWsMap = {};
        let nameToLineChartMap = {};
        let headerNameToValueMap = {
            "Content-Type": "application/json",
            "Accept": "*/*",
            "Accept-Encoding": "gzip, deflate, br",
            "Connection": "keep-alive"
        };

        window.onload = (event) => {
            registerSlider();
            registerSubmitNewPreyEventListener();
            reloadPreys();
            registerAddHeaderButtonButton();
            renderHeaders()
        };

        function renderPrey(name, url, method, requestParameters, headers, requestBody, timeoutMs) {
            const listElementId = "prey_" + name;
            const accordionButtonId = "prey_name_" + name;
            const bodyId = "prey_url_" + name;
            const deleteButtonId = "prey_button_" + name;
            const accordionId = "prey_accordion_" + name;
            let headersList = "";
            for (const header in headers) {
                if (header) {
                    headersList += `<div>${header}: ${headers[header]}</div>`;
                }
            }
            const listElement = `
                <li id="${listElementId}" class="container list-group-item">
                    <div class="row">
                        <div class="accordion accordion-flush col" id="accordionFlushExample">
                            <div class="accordion-item">
                                <div class="accordion-header" id="flush-headingOne">
                                    <button id="${accordionButtonId}" class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#${accordionId}" aria-expanded="false" aria-controls="flush-collapseOne">${name}</button>
                                </div>
                                <div id="${accordionId}" class="accordion-collapse collapse" aria-labelledby="flush-headingOne" data-bs-parent="#accordionFlushExample">
                                <div class="row">
                                    <div id="${bodyId}" class="accordion-body col">${method}: ${url}${requestParameters ? '?' + requestParameters : ''}</div>
                                    <div class="accordion-body col-md-2 d-flex justify-content-end">(timeout ${timeoutMs} ms)</div>
                                </div>
                                    ${headersList ? `<div class="accordion-body">${headersList}</div>` : ""}
                                    ${requestBody ? `
                                    <div class="accordion-body">
                                        <textarea class="form-control" rows="6" disabled>${requestBody}</textarea>
                                    </div>
                                    ` : ''}
                                </div>
                            </div>
                        </div>

                        <div class="col-md-1 d-flex justify-content-end">
                            <button id="${deleteButtonId}" type="button" class="btn btn-outline-danger">
                                <svg id="svgDash" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-dash" viewBox="0 0 16 16">
                                    <path d="M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </li>
            `;

            document.getElementById("preyList").insertAdjacentHTML("beforeend", listElement);

            registerDeleteItemButton(deleteButtonId, name);
        }

        function registerSlider() {
            const rpsSlide = document.getElementById('rpsSlide');
            const rpsSliderDiv = document.getElementById("sliderAmount");
            rpsSlide.onchange = function () {
                rpsSliderDiv.innerHTML = this.value;
                loadServices(this.value);
            }

            fetch("http://localhost:8088/loadParameters", {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            }).then(preys => preys.json())
                .then(loadParameters => {
                    rpsSlide.value = loadParameters.rps;
                    rpsSliderDiv.innerHTML = loadParameters.rps;
                });
        }

        function registerSubmitNewPreyEventListener() {
            const preyConfigForm = document.getElementById("preyConfigForm");
            preyConfigForm.addEventListener("submit", event => {

                const newPreyName = document.getElementById("newPreyName").value;
                const newPreyUrl = document.getElementById("newPreyUrl").value;
                const method = Array.from(document.getElementById("httpMethodSelector").children).find((selector) => selector.checked).value;
                const loadRequestParams = document.getElementById("loadRequestParams").value;
                const loadRequestBody = document.getElementById("loadRequestBody").value;
                const responseTimeout = document.getElementById("responseTimeoutInputId").value;

                if (preyConfigForm.checkValidity()) {
                    if (!preysToLoad[newPreyName]) {
                        preysToLoad[newPreyName] = newPreyUrl;
                        registerPrey(newPreyName, newPreyUrl, method, loadRequestParams, headerNameToValueMap, loadRequestBody, responseTimeout);
                    }
                } else {
                    event.stopPropagation();
                }

                preyConfigForm.classList.add('was-validated')
                event.preventDefault();
            });
        }


        function registerDeleteItemButton(id, name) {
            document.getElementById(id).onclick = function () {

                if (preysToLoad[name]) {
                    unregisterPrey(name);
                }
            }
        }

        function reloadPreys() {
            const preyList = document.getElementById("preyList");
            preyList.innerHTML = "";
            const chartContainer = document.getElementById("chartContainer");
            chartContainer.innerHTML = "";
            preysToLoad = {};
            nameToWsMap = {};
            nameToLineChartMap = {};

            fetch("http://localhost:8088/prey", {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            }).then(preys => preys.json())
                .then(preys => {
                    preys.forEach((prey, index, array) => {
                        const name = prey.name;
                        const url = prey.path;
                        const method = prey.method;
                        const requestParameters = prey.requestParameters;
                        const headers = prey.headers;
                        const requestBody = prey.requestBody;
                        preysToLoad[name] = url;
                        renderPrey(name, url, method, requestParameters, headers, requestBody);
                        renderPreyChart(name);
                        connectToWs(name);
                    });
                });
        }

        function registerPrey(name, url, method, requestParameters, headers, requestBody, responseTimeout) {
            const body = {
                name: name,
                path: url,
                method: method,
                requestParameters: requestParameters,
                headers: headers,
                requestBody: requestBody,
                timeoutMs: responseTimeout
            }

            fetch("http://localhost:8088/prey", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
            }).then(date => {
                reloadPreys();
            });
        }

        function unregisterPrey(name) {
            fetch("http://localhost:8088/prey/" + name, {
                method: "DELETE",
                headers: {
                    "Content-Type": "application/json"
                }
            }).then(date => {
                reloadPreys();
            });
        }

        function connectToWs(name) {
            const loadServiceWs = new WebSocket("ws://localhost:8088/websocket/load?" + name, []);
            nameToWsMap[name] = loadServiceWs;
            loadServiceWs.onmessage = (event) => {
                updateNamedLineChart(name, JSON.parse(event.data));
            }
        }

        function renderPreyChart(name) {
            addCanvas(name);
            const chartContainer = {};
            const totalCount = [];
            const responseTime = [];
            const successCount = [];
            const timeoutCount = [];
            const errorCount = [];
            chartContainer["totalCount"] = totalCount;
            chartContainer["responseTime"] = responseTime;
            chartContainer["successCount"] = successCount;
            chartContainer["timeoutCount"] = timeoutCount;
            chartContainer["errorCount"] = errorCount;
            chartContainer["lineChart"] = new Chart(name + "_lineChart", {
                type: "line",
                data: {
                    labels: totalCount,
                    datasets: [
                        {
                            label: name + ' | Response time, ms',
                            fill: false,
                            borderColor: 'rgb(0, 0, 255, 1)',
                            backgroundColor: 'rgb(0, 0, 255, 0.6)',
                            pointStyle: 'circle',
                            pointRadius: 8,
                            pointHoverRadius: 15,
                            data: responseTime,
                            yAxisID: "axisResponseTime"
                        },
                        {
                            label: name + ' | success count',
                            fill: false,
                            borderColor: 'rgb(0, 255, 0, 1)',
                            backgroundColor: 'rgb(0, 255, 0, 0.6)',
                            pointStyle: 'circle',
                            pointRadius: 8,
                            pointHoverRadius: 15,
                            data: successCount,
                            yAxisID: "axisSuccessCount"
                        },
                        {
                            label: name + ' | timeout count',
                            fill: false,
                            borderColor: 'rgb(255, 255, 0, 1)',
                            backgroundColor: 'rgb(255, 255, 0, 0.6)',
                            pointStyle: 'circle',
                            pointRadius: 8,
                            pointHoverRadius: 15,
                            data: timeoutCount,
                            yAxisID: "axisTimeoutCount"
                        },
                        {
                            label: name + ' | error count',
                            fill: false,
                            borderColor: 'rgb(255, 0, 0, 1)',
                            backgroundColor: 'rgb(255, 0, 0, 0.6)',
                            pointStyle: 'circle',
                            pointRadius: 8,
                            pointHoverRadius: 15,
                            data: errorCount,
                            yAxisID: "axisErrorsCount"
                        }
                    ]
                },
                options: {
                    legend: {display: true},
                    title: {
                        display: true,
                        text: "p = np",
                        fontSize: 16
                    },
                    scales: {
                        axisResponseTime: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            text: 'response time'
                            // grid: {
                            //     drawOnChartArea: false, // only want the grid lines for one axis to show up
                            // },
                        },
                        axisTimeoutCount: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            text: 'errors count',
                            grid: {
                                drawOnChartArea: false, // only want the grid lines for one axis to show up
                            },
                        },
                        axisErrorsCount: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            text: 'errors count',
                            grid: {
                                drawOnChartArea: false, // only want the grid lines for one axis to show up
                            },
                        },
                        axisSuccessCount: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            text: 'success count',
                            grid: {
                                drawOnChartArea: false, // only want the grid lines for one axis to show up
                            },
                        },
                    }
                }
            });

            nameToLineChartMap[name] = chartContainer;
        }

        function updateNamedLineChart(name, report) {
            const chartContainer = nameToLineChartMap[name];
            safePush(chartContainer["responseTime"], report["endMs"] - report["startMs"]);
            const summary = report["summary"];
            safePush(chartContainer["totalCount"], summary + ' - ' + report["totalCount"]);

            if (summary === "SUCCESS") {
                const numbers = chartContainer["successCount"];
                const nextVal = getNextValue(numbers);
                safePush(numbers, nextVal);
            } else if (summary === "TIMEOUT") {
                const numbers = chartContainer["timeoutCount"];
                const nextVal = getNextValue(numbers);
                safePush(numbers, nextVal);
            } else if (summary === "ERROR") {
                const numbers = chartContainer["errorCount"];
                const nextVal = getNextValue(numbers);
                safePush(numbers, nextVal);
            }

            chartContainer["lineChart"].update();
        }

        function getNextValue(arr) {
            const size = arr.length;

            if (size === 0) {
                return 1;
            }

            return arr[arr.length - 1] + 1;
        }

        function loadServices(rps) {
            const msg = {
                rps: rps,
                stopWhenDisconnect: false
            }

            for (const name in preysToLoad) {
                nameToWsMap[name].send(JSON.stringify(msg));
            }
        }

        function safePush(arr, element, maxSize = 100) {
            if (arr.length > maxSize) {
                arr.shift();
            }

            arr.push(element);
        }

        function addCanvas(name) {
            const newCanvas = document.createElement("canvas");
            newCanvas.setAttribute("id", name + "_lineChart");
            newCanvas.setAttribute("width", "100%");
            newCanvas.setAttribute("height", "22");
            const container = document.getElementById("chartContainer");
            container.appendChild(newCanvas);
        }

        function getRandomColor() {
            return "#" + ((1 << 24) * Math.random() | 0).toString(16);
        }

        function renderHeaders() {
            const headerList = document.getElementById("headerList");
            headerList.innerHTML = "";

            for (const name in headerNameToValueMap) {
                renderHeader(name, headerNameToValueMap[name]);
            }
        }

        function renderHeader(name, value) {
            const listElementId = "header_" + name;
            const headerNameId = "header_name_" + name;
            const headerValueId = "header_" + value;
            const deleteHeaderButtonId = "delete_header_button_" + name;
            const listElement = `
                <li id="${listElementId}" class="container list-group-item">
                    <div class="row">
                        <div class="col-md-5 align-self-center">
                            <div id="${headerNameId}">${name}</div>
                        </div>

                        <div class="col align-self-center">
                            <div id="${headerValueId}">${value}</div>
                        </div>

                        <div class="col-md-1 d-flex justify-content-end">
                            <button id="${deleteHeaderButtonId}" type="button" class="btn btn-outline-danger">
                                <svg id="svgDash" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-dash" viewBox="0 0 16 16">
                                    <path d="M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </li>
            `;

            document.getElementById("headerList").insertAdjacentHTML("beforeend", listElement);

            registerDeleteHeaderButton(deleteHeaderButtonId, name);
        }

        function registerAddHeaderButtonButton() {
            document.getElementById("addHeaderButton").onclick = function () {
                headerNameToValueMap[document.getElementById("loadHeaderName").value] = document.getElementById("loadHeaderValue").value;

                renderHeaders();
            }
        }

        function registerDeleteHeaderButton(id, name) {
            document.getElementById(id).onclick = function () {
                delete headerNameToValueMap[name];
                renderHeaders();
            }
        }
    </script>
    <title></title>
</head>
<body>

<form id="preyConfigForm" name="preyConfigForm" class="container mt-2 needs-validation" novalidate accept-charset="UTF-8">
    <div class="mt-2 row d-flex align-items-end">
        <div class="col-md-3">
            <label for="newPreyName" class="form-label">Name</label>
            <input id="newPreyName" type="text" class="form-control" placeholder="My service" aria-label="Name" required>
            <div class="invalid-feedback">
                Name can't be empty
            </div>
        </div>

        <div class="col">
            <label for="newPreyUrl" class="form-label">Url</label>
            <input id="newPreyUrl" type="text" class="form-control" placeholder="https://example.com" aria-label="Url" required>
            <div class="invalid-feedback">
                Target URL can't be empty
            </div>
        </div>

        <div class="col-md-1 d-flex justify-content-end">
            <button id="additionalFields" type="button" class="btn btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#additionalFieldsForm">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-chevron-compact-down" viewBox="0 0 16 16">
                    <path fill-rule="evenodd"
                          d="M1.553 6.776a.5.5 0 0 1 .67-.223L8 9.44l5.776-2.888a.5.5 0 1 1 .448.894l-6 3a.5.5 0 0 1-.448 0l-6-3a.5.5 0 0 1-.223-.67z"/>
                </svg>
            </button>
        </div>

    </div>

    <div id="additionalFieldsForm" class="collapse">
        <div class="row mt-2 d-flex align-items-end">
            <div class="col">
                <label for="httpMethodSelector" class="form-label">Method</label>
                <div id="httpMethodSelector" class="container btn-group col" role="group" aria-label="Http methods group">
                    <input type="radio" class="btn-check" name="btnradio" id="btnradioWS" autocomplete="off" value="WS">
                    <label class="btn btn-outline-warning" for="btnradioWS">WS</label>

                    <input type="radio" class="btn-check" name="btnradio" id="btnradioGET" autocomplete="off" value="GET" checked>
                    <label class="btn btn-outline-primary" for="btnradioGET">GET</label>

                    <input type="radio" class="btn-check" name="btnradio" id="btnradioPOST" autocomplete="off" value="POST">
                    <label class="btn btn-outline-primary" for="btnradioPOST">POST</label>

                    <input type="radio" class="btn-check" name="btnradio" id="btnradioPUT" autocomplete="off" value="PUT">
                    <label class="btn btn-outline-primary" for="btnradioPUT">PUT</label>

                    <input type="radio" class="btn-check" name="btnradio" id="btnradioPATCH" autocomplete="off" value="PATCH">
                    <label class="btn btn-outline-primary" for="btnradioPATCH">PATCH</label>

                    <input type="radio" class="btn-check" name="btnradio" id="btnradioDELETE" autocomplete="off" value="DELETE">
                    <label class="btn btn-outline-primary" for="btnradioDELETE">DELETE</label>

                    <input type="radio" class="btn-check" name="btnradio" id="btnradioHEAD" autocomplete="off" value="HEAD">
                    <label class="btn btn-outline-primary" for="btnradioHEAD">HEAD</label>

                    <input type="radio" class="btn-check" name="btnradio" id="btnradioOPTIONS" autocomplete="off" value="OPTIONS">
                    <label class="btn btn-outline-primary" for="btnradioOPTIONS">OPTIONS</label>
                </div>
            </div>

            <div class="col-md-2">
                <label for="responseTimeoutInputId" class="form-label">Timeout, ms</label>
                <input type="number" class="form-control" id="responseTimeoutInputId" value="10000">
            </div>
        </div>

        <div class="mt-2">
            <label for="loadRequestParams" class="form-label">Request parameters</label>
            <textarea class="form-control" id="loadRequestParams" rows="1" placeholder="firstname=John&lastname=Doe&age=1984"></textarea>
        </div>

        <div class="mt-2 row d-flex align-items-end">
            <div class="col-md-5">
                <label for="loadHeaderName" class="form-label">Header name</label>
                <input type="text" class="form-control" id="loadHeaderName" placeholder="My-Custom-Header-Name"/>
            </div>

            <div class="col">
                <label for="loadHeaderValue" class="form-label">Header value</label>
                <input type="text" class="form-control" id="loadHeaderValue" placeholder="X-custom-header-value"/>
            </div>

            <div class="col-md-1 d-flex justify-content-end">
                <button id="addHeaderButton" type="button" class="btn btn-outline-primary">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-plus" viewBox="0 0 16 16">
                        <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
                    </svg>
                </button>
            </div>

            <div class="container mt-2">
                <ul id="headerList" class="list-group"></ul>
            </div>
        </div>

        <div class="mb-3 mt-2">
            <label for="loadRequestBody" class="form-label">Request body</label>
            <textarea class="form-control" id="loadRequestBody" rows="3"></textarea>
        </div>

    </div>

    <div class="mt-4">
        <button id="addItemButton" type="submit" class="btn btn-outline-primary col-md-12">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-plus" viewBox="0 0 16 16">
                <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
            </svg>
        </button>
    </div>
</form>

<div class="container mt-2">
    <ul id="preyList" class="list-group"></ul>
</div>

<div class="container slider-container mt-2 col-md-12">
    <div>
        <label class="form-label" for="rpsSlide">Load, RPS:&nbsp;</label><span class="form-label" style="font-weight: bold" id="sliderAmount">0</span>
    </div>
    <input id="rpsSlide" name="rpsSlide" type="range" min="0" max="1000" step="4" value="0" list="tickmarks" class="form-range"/>
</div>

<div class="container">
    <datalist id="tickmarks" class=" col-md-12">
        <option value="0" label="disable"></option>
        <option value="100" label="100"></option>
        <option value="200" label="200"></option>
        <option value="300" label="300"></option>
        <option value="400" label="400"></option>
        <option value="500" label="500"></option>
        <option value="600" label="600"></option>
        <option value="700" label="700"></option>
        <option value="800" label="800"></option>
        <option value="900" label="900"></option>
        <option value="1000" label="1000"></option>
    </datalist>
</div>

<!-- chart -->
<div id="chartContainer"></div>

</body>
</html>
